<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CMake &mdash; X-NOTES latest 文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> X-NOTES
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Linux/Linux.html">Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="cmake.html">CMake</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">X-NOTES</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>CMake</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Cmake/cmake笔记2.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="cmake">
<h1>CMake<a class="headerlink" href="#cmake" title="永久链接至标题">¶</a></h1>
</section>
<section id="id1">
<h1>说明<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>cmake的定义是什么 ？—–高级编译配置工具</p>
<p>当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了—–CMake！</p>
<p>所有操作都是通过编译CMakeLists.txt来完成的—简单</p>
<p>官 方网站是 <a class="reference external" href="http://www.cmake.org/">www.cmake.org</a>，可以通过访问官方网站获得更多关于 cmake 的信息</p>
<p>学习CMake的目的，为将来处理大型的C/C++/JAVA项目做准备</p>
</section>
<section id="id2">
<h1>CMake安装<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h1>
<p>1、绝大多数的linux系统已经安装了CMake</p>
<p>2、Windows或某些没有安装过的linux系统，去<a class="reference external" href="http://www.cmake.org/HTML/Download.html">http://www.cmake.org/HTML/Download.htm</a>l  可以下载安装</p>
</section>
<section id="cmakehelloword">
<h1>CMake一个HelloWord<a class="headerlink" href="#cmakehelloword" title="永久链接至标题">¶</a></h1>
<p>1、步骤一，写一个HelloWord</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#main.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span>  <span class="s">&quot;hello word&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>2、步骤二，写CMakeLists.txt</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#CMakeLists.txt

PROJECT (HELLO)

SET(SRC_LIST main.cpp)

MESSAGE(STATUS &quot;This is BINARY dir &quot; ${HELLO_BINARY_DIR})

MESSAGE(STATUS &quot;This is SOURCE dir &quot;${HELLO_SOURCE_DIR})

ADD_EXECUTABLE(hello ${SRC_LIST})
</pre></div>
</div>
<p>3、步骤三、使用cmake，生成makefile文件</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>cmake .

输出：
[root@localhost cmake]# cmake .
CMake Warning (dev) in CMakeLists.txt:
  Syntax Warning in cmake code at

    /root/cmake/CMakeLists.txt:7:37

  Argument not separated from preceding token by whitespace.
This warning is for project developers.  Use -Wno-dev to suppress it.

-- The C compiler identification is GNU 10.2.1
-- The CXX compiler identification is GNU 10.2.1
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- This is BINARY dir /root/cmake
-- This is SOURCE dir /root/cmake
-- Configuring done
-- Generating done
-- Build files have been written to: /root/cmake
</pre></div>
</div>
<p>目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.
现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile.</p>
<p>4、使用make命令编译</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>root@localhost cmake]# make
Scanning dependencies of target hello
[100%] Building CXX object CMakeFiles/hello.dir/main.cpp.o
Linking CXX executable hello
[100%] Built target hello
</pre></div>
</div>
<p>5、最终生成了Hello的可执行程序</p>
</section>
<section id="id3">
<h1>CMake一个HelloWord-的语法介绍<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h1>
<section id="project">
<h2>PROJECT关键字<a class="headerlink" href="#project" title="永久链接至标题">¶</a></h2>
<p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p>
<p>PROJECT (HELLO)   指定了工程的名字，并且支持所有语言—建议</p>
<p>PROJECT (HELLO CXX)      指定了工程的名字，并且支持语言是C++</p>
<p><strong>PROJECT (HELLO C CXX)      指定了工程的名字，并且支持语言是C和C++</strong></p>
<p>该指定隐式定义了两个CMAKE的变量</p>
<p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</p>
<p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</p>
<p><strong>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录</strong>，后面会讲外部编译</p>
<p>问题：如果改了工程名，这两个变量名也会改变</p>
<p>解决：又定义两个预定义变量：<strong>PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR</strong>，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p>
</section>
<section id="set">
<h2>SET关键字<a class="headerlink" href="#set" title="永久链接至标题">¶</a></h2>
<p><strong>用来显示的指定变量的</strong></p>
<p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p>
<p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p>
</section>
<section id="message">
<h2>MESSAGE关键字<a class="headerlink" href="#message" title="永久链接至标题">¶</a></h2>
<p><strong>向终端输出用户自定义的信息</strong></p>
<p>主要包含三种信息：</p>
<ul class="simple">
<li><p>SEND_ERROR，产生错误，生成过程被跳过。</p></li>
<li><p>SATUS，输出前缀为—的信息。</p></li>
<li><p>FATAL_ERROR，立即终止所有 cmake 过程.</p></li>
</ul>
</section>
<section id="add-executable">
<h2>ADD_EXECUTABLE关键字<a class="headerlink" href="#add-executable" title="永久链接至标题">¶</a></h2>
<p><strong>生成可执行文件</strong></p>
<p>ADD_EXECUTABLE(hello ${SRC_LIST})     <strong>生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</strong></p>
<p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p>
<p><img alt="image-20220728090945010" src="Cmake/cmake%E7%AC%94%E8%AE%B0.assets/image-20220728090945010.png" /></p>
<p>上述例子可以简化的写成</p>
<p>PROJECT(HELLO)
ADD_EXECUTABLE(hello main.cpp)</p>
<p>注意：<strong>工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</strong></p>
</section>
</section>
<section id="id4">
<h1>语法的基本原则<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h1>
<ul>
<li><p><strong>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</strong></p></li>
<li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p>
<p>就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p>
</li>
<li><p><strong>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</strong></p></li>
</ul>
<section id="id5">
<h2>语法注意事项<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，<strong>如果源文件名中含有空格，就必须要加双引号</strong></p></li>
<li><p>ADD_EXECUTABLE(hello main) 后缀可以不写，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</p></li>
</ul>
</section>
</section>
<section id="id6">
<h1>内部构建和外部构建<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><p>上述例子就是内部构建，他生产的临时文件特别多，不方便清理</p></li>
<li><p><strong>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</strong></p></li>
</ul>
<section id="id7">
<h2>外部构建方式举例<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>//例子目录，CMakeLists.txt和上面例子一致
[root@localhost cmake]# pwd
/root/cmake
[root@localhost cmake]# ll
total 8
-rw-r--r--. 1 root root 198 Dec 28 20:59 CMakeLists.txt
-rw-r--r--. 1 root root  76 Dec 28 00:18 main.cpp
</pre></div>
</div>
<p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p>
<p>2、<strong>进入build，运行cmake ..</strong>    当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p>
<p>3、<strong>在build目录下，运行make来构建工程</strong></p>
<p>注意外部构建的两个变量</p>
<p>1、HELLO_SOURCE_DIR  还是工程路径</p>
<p>2、HELLO_BINARY_DIR   编译路径 也就是 /root/cmake/bulid</p>
</section>
</section>
<section id="hello-world">
<h1>让Hello World看起来更像一个工程<a class="headerlink" href="#hello-world" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><p>为工程添加一个子目录 src，用来放置工程源代码</p></li>
<li><p>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</p></li>
<li><p>在工程目录添加文本文件 COPYRIGHT, README</p></li>
<li><p>在工程目录添加一个 <a class="reference external" href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</p></li>
<li><p>将构建后的目标文件放入构建目录的 bin 子目录</p></li>
<li><p>将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/</p></li>
</ul>
<section id="bin">
<h2>将目标文件放入构建目录的 bin 子目录<a class="headerlink" href="#bin" title="永久链接至标题">¶</a></h2>
<p><strong>每个目录下都要有一个CMakeLists.txt说明</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>[root@localhost cmake]# tree
.
├── build
├── CMakeLists.txt
└── src
    ├── CMakeLists.txt
    └── main.cpp
</pre></div>
</div>
<p>外层CMakeLists.txt</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PROJECT</span><span class="p">(</span><span class="n">HELLO</span><span class="p">)</span>
<span class="n">ADD_SUBDIRECTORY</span><span class="p">(</span><span class="n">src</span> <span class="n">bin</span><span class="p">)</span>  <span class="c1">// 关联  // bin并可以指定中间二进制和目标二进制存放的位置</span>
</pre></div>
</div>
<p>src下的CMakeLists.txt</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ADD_EXECUTABLE</span><span class="p">(</span><span class="n">hello</span> <span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">)</span>
</pre></div>
</div>
<section id="add-subdirectory">
<h3>ADD_SUBDIRECTORY 指令<a class="headerlink" href="#add-subdirectory" title="永久链接至标题">¶</a></h3>
<p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p>
<ul>
<li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li>
<li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li>
<li><p>ADD_SUBDIRECTORY(src bin)</p>
<p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p>
<p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</p>
</li>
</ul>
</section>
<section id="id8">
<h3>更改二进制的保存路径<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p>
<p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</p>
<p>思考：加载哪个CMakeLists.txt当中</p>
<p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p>
</section>
</section>
</section>
<section id="id9">
<h1>安装<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><p>一种是从代码编译后直接 make install 安装</p></li>
<li><p>一种是打包时的指定 目录安装。</p>
<ul>
<li><p>简单的可以这样指定目录：make install DESTDIR=/tmp/test</p></li>
<li><p>稍微复杂一点可以这样指定目录：./configure –prefix=/usr</p></li>
</ul>
</li>
</ul>
<section id="helloword">
<h2>如何安装HelloWord<a class="headerlink" href="#helloword" title="永久链接至标题">¶</a></h2>
<p><strong>使用CMAKE一个新的指令：INSTALL</strong></p>
<p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p>
<p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>// 目录树结构
[root@localhost cmake]# tree
.
├── build
├── CMakeLists.txt
├── COPYRIGHT             // 版权
├── doc
│   └── hello.txt        // 文本
├── README
├── runhello.sh           // j
└── src
    ├── CMakeLists.txt
    └── main.cpp

3 directories, 7 files
</pre></div>
</div>
<section id="copyrightreadme">
<h3>安装文件COPYRIGHT和README<a class="headerlink" href="#copyrightreadme" title="永久链接至标题">¶</a></h3>
<p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</p>
<p>FILES：文件</p>
<p>DESTINATION：</p>
<p>1、写绝对路径</p>
<p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/&lt;DESTINATION 定义的路径&gt;</p>
<p>CMAKE_INSTALL_PREFIX  默认是在 /usr/local/</p>
<p>cmake -DCMAKE_INSTALL_PREFIX=/usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p>
</section>
<section id="runhello-sh">
<h3>安装脚本runhello.sh<a class="headerlink" href="#runhello-sh" title="永久链接至标题">¶</a></h3>
<p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p>
<p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p>
<p>说明：实际安装到的是 /usr/bin</p>
</section>
<section id="doc-hello-txt">
<h3>安装 doc 中的 hello.txt<a class="headerlink" href="#doc-hello-txt" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li>
<li><p>二、是直接在工程目录通过</p>
<p>INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p>
</li>
</ul>
<p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p>
<p>注意：abc 和 abc/有很大的区别</p>
<p>目录名不以/结尾：这个目录将被安装为目标路径下的</p>
<p>目录名以/结尾：将这个目录中的内容安装到目标路径</p>
</section>
<section id="id10">
<h3>安装过程<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>cmake ..</p>
<p>make</p>
<p>make install</p>
</section>
</section>
</section>
<section id="id11">
<h1>静态库和动态库的构建<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h1>
<p>任务：</p>
<p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。</p>
<p>２，安装头文件与共享库。</p>
<p><strong>静态库和动态库的区别</strong></p>
<ul class="simple">
<li><p>静态库的扩展名一般为  “.a”或“.lib”；  动态库的扩展名一般为“.so”或“.dll”。</p></li>
<li><p><strong>静态库在编译时会直接整合到目标程序中</strong>，编译成功的,离开库也可以 可执行文件可独立运行</p></li>
<li><p>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</p></li>
</ul>
<section id="id12">
<h2>构建实例<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>[root@localhost cmake2]# tree
.
├── build
├── CMakeLists.txt
└── lib
    ├── CMakeLists.txt
    ├── hello.cpp
    └── hello.h
</pre></div>
</div>
<p>hello.h中的内容</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef HELLO_H</span>
<span class="cp">#define Hello_H</span>

<span class="kt">void</span> <span class="nf">HelloFunc</span><span class="p">();</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p>hello.cpp中的内容</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hello.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">HelloFunc</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello World&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>项目中的cmake内容</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PROJECT</span><span class="p">(</span><span class="n">HELLO</span><span class="p">)</span>
<span class="n">ADD_SUBDIRECTORY</span><span class="p">(</span><span class="n">lib</span> <span class="n">bin</span><span class="p">)</span>
</pre></div>
</div>
<p>lib中CMakeLists.txt中的内容</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>SET(LIBHELLO_SRC hello.cpp)
ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
</pre></div>
</div>
<section id="add-library">
<h3>ADD_LIBRARY<a class="headerlink" href="#add-library" title="永久链接至标题">¶</a></h3>
<p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p>
<ul>
<li><p><strong>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</strong></p></li>
<li><p>SHARED，动态库    STATIC，静态库</p></li>
<li><p>${LIBHELLO_SRC} ：源文件</p>
<p><strong>生成在 build/bin中</strong></p>
</li>
</ul>
<p><img alt="image-20220812150045394" src="Cmake/cmake%E7%AC%94%E8%AE%B0.assets/image-20220812150045394.png" /></p>
</section>
<section id="id13">
<h3>同时构建静态和动态库<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a
ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
ADD_LIBRARY(hello STATIC ${LIBHELLO_SRC})

// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已
ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})
</pre></div>
</div>
</section>
<section id="set-target-properties">
<h3>SET_TARGET_PROPERTIES<a class="headerlink" href="#set-target-properties" title="永久链接至标题">¶</a></h3>
<p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p>
<p><strong>同时构建静态和动态库</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>SET(LIBHELLO_SRC hello.cpp)

    
    
ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})

//对hello_static的重名为hello
SET_TARGET_PROPERTIES(hello_static PROPERTIES  OUTPUT_NAME &quot;hello&quot;)
//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a
SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)

    
    
ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})

SET_TARGET_PROPERTIES(hello PROPERTIES  OUTPUT_NAME &quot;hello&quot;)
SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1)
</pre></div>
</div>
<p><img alt="image-20220812145917499" src="Cmake/cmake%E7%AC%94%E8%AE%B0.assets/image-20220812145917499.png" /></p>
</section>
<section id="id14">
<h3>动态库的版本号<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>一般动态库都有一个版本号的关联</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">libhello</span><span class="p">.</span><span class="n">so</span><span class="mf">.1.2</span>
<span class="n">libhello</span><span class="p">.</span><span class="n">so</span> <span class="o">-&gt;</span><span class="n">libhello</span><span class="p">.</span><span class="n">so</span><span class="mf">.1</span>
<span class="n">libhello</span><span class="p">.</span><span class="n">so</span><span class="mf">.1</span><span class="o">-&gt;</span><span class="n">libhello</span><span class="p">.</span><span class="n">so</span><span class="mf">.1.2</span>
</pre></div>
</div>
<p>CMakeLists.txt 插入如下</p>
<p><code class="docutils literal notranslate"><span class="pre">SET_TARGET_PROPERTIES(hello</span> <span class="pre">PROPERTIES</span> <span class="pre">VERSION</span> <span class="pre">1.2</span> <span class="pre">SOVERSION</span> <span class="pre">1)</span></code></p>
<p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p>
</section>
<section id="id15">
<h3>安装共享库和头文件<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>本例中我们将 hello 的共享库安装到<prefix>/lib目录，</p>
<p>将 hello.h 安装到<prefix>/include/hello 目录</p>
<img src="cmake笔记.assets/image-20220812150259649.png" alt="image-20220812150259649" style="zoom: 67%;" /><p>进入 cmakelists.txt</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//文件放到该目录下</span>
<span class="n">INSTALL</span><span class="p">(</span><span class="n">FILES</span> <span class="n">hello</span><span class="p">.</span><span class="n">h</span> <span class="n">DESTINATION</span> <span class="n">include</span><span class="o">/</span><span class="n">hello</span><span class="p">)</span>

<span class="c1">//二进制，静态库，动态库安装都用TARGETS</span>
<span class="c1">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span>
<span class="n">INSTALL</span><span class="p">(</span><span class="n">TARGETS</span> <span class="n">hello</span> <span class="n">hello_static</span> <span class="n">LIBRARY</span> <span class="n">DESTINATION</span> <span class="n">lib</span> <span class="n">ARCHIVE</span> <span class="n">DESTINATION</span> <span class="n">lib</span><span class="p">)</span>
</pre></div>
</div>
<p>注意：</p>
<p>安装的时候，指定一下路径，放到系统下</p>
<p><code class="docutils literal notranslate"><span class="pre">cmake</span> <span class="pre">-D</span> <span class="pre">CMAKE_INSTALL_PREFIX=/usr</span> <span class="pre">..</span></code></p>
</section>
<section id="id16">
<h3>使用外部共享库和头文件<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>准备工作，新建一个目录来使用外部共享库和头文件</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>[root@MiWiFi-R4CM-srv cmake3]# tree
.
├── build
├── CMakeLists.txt
└── src
    ├── CMakeLists.txt
    └── main.cpp
</pre></div>
</div>
<p>main.cpp</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;hello.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">HelloFunc</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="make">
<h3>解决：make后头文件找不到的问题<a class="headerlink" href="#make" title="永久链接至标题">¶</a></h3>
<p>PS：include &lt;hello/hello.h&gt;  这样include是可以，这么做的话，就没啥好讲的了</p>
<p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p>
</section>
<section id="id17">
<h3>解决：找到引用的函数问题<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>报错信息：undefined reference to `HelloFunc()’</p>
<p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p>
<p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p>
<p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p>
<p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p>
<p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p>
<p>查看main的链接情况</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>[root@MiWiFi-R4CM-srv bin]# ldd main 
	linux-vdso.so.1 =&gt;  (0x00007ffedfda4000)
	libhello.so =&gt; /lib64/libhello.so (0x00007f41c0d8f000)
	libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f41c0874000)
	libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f41c0572000)
	libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f41c035c000)
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f41bff8e000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f41c0b7c000)
</pre></div>
</div>
<p>链接静态库</p>
<p><code class="docutils literal notranslate"><span class="pre">TARGET_LINK_LIBRARIES(main</span> <span class="pre">libhello.a)</span></code></p>
</section>
<section id="cmake-include-path-cmake-library-path">
<h3>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH<a class="headerlink" href="#cmake-include-path-cmake-library-path" title="永久链接至标题">¶</a></h3>
<p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p>
<p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</p>
<p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p>
<p>补充：生产debug版本的方法：
cmake .. -DCMAKE_BUILD_TYPE=debug</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, JinDao.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>