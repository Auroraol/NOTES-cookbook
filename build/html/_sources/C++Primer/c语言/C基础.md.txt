# 一、vs的使用和快捷键

1. Ctrl+F5运行但不调试

2. F5直接调试  可能会闪退(使用system(pause) 头文件 #include<stdlib.h>)
3. 对代码进行语法检查1, ctrl + Shift +B   编译代码，(生成解决方案)
4. Ctrl +F   编译代码



# 二、计算机组成原理

## 2.1 进制理论

进制也就是进位计数制，是人为定义的带进位的计数方法。 对于任何一种进制---N进制，就表示每一位置上的数运算时都是逢N进一位。 

比如0 1 2 3 4 5 6 7 8 9 10 11 12 13...，在数数时某一位数量满10了就向前进位，这种逢十进一的进位制，就叫十进制。比如1小时有60分钟，1分钟有60秒，满60进一，这就是六十进制。

而在计算机中常用的进制除了``十进制``，还有``二进制``、``八进制``、``十六进制``

 **二进制**

组成：0 1

规则：逢二进一

表示方式：二进制数1000010可写成(1000010)2 或写成1000010B

 **八进制**

组成：0 1 2 3 4 5 6 7

规则：逢八进一

表示方式：八进制数520可写成(520)8 或写成520O

  **十六进制**

组成：0 1 2 3 4 5 6 7 8 9 A B C D E F  (A代表10 以此类推)

规则：逢十六进一

表示方式：十六进制的520可以写成(520)16 或写成520H



**在计算机中，有这么多种进制表示方式原因**

+ 方便：二进制数中只有两个数码0和1，可用具有两个不同稳定状态的元器件来表示一位数码。

+ 简单：二进制数运算简单，大大简化了计算中运算部件的结构，0+0=0，0+1=1，1+0=1，1+1=10。

+ 真假：二进制天然兼容逻辑运算。

+ 缺点：二进制计数在日常使用上有个不便之处，就是位数往往很长，读写不便，如：把十进制的100000D写成二进制就是11000011010100000B，所以计算机领域我们实际采用的是十六进制。二进制数转换为十六进制数时，长度缩减为原先的约四分之一，把十进制的100000写成八进制就是303240。十六进制的一个数位可代表二进制的四个数位。这样，十进制的100000写成十六进制就是186A0。

  

## 2.2 存储单位

我们平常使用的程序，如：Windows操作系统、打字软件、游戏软件等。一般安装在硬盘等外存上，但仅此是不能使用其功能，必须把它们调入内存中运行，才能真正使用其功能。

因为内存的读写速度相对于外存来说非常快，但是内存是暂时存储程序以及数据的地方。当我们使用WPS处理文稿时，当你在键盘上敲入字符时，它被存入内存中。当你选择存盘时，内存中的数据才会被存入硬（磁）盘。

内存是由无数个晶体管组成的(可以理解为灯泡)，一个晶体管作为一比特(bit)的存储器。每个晶体管可以存储一个二进制0或1，比特通常也叫做位。



**位(bit)**：		   计算机存储的最小单位

**字节(byte):**	   数据表示的最小单位

+ **一个字节 通常等于 8位  (1 byte   =  8 bit  =  8个二进制数)**
+ 记忆:  位数就是2进制数个数

**千字节(KB)：**

+ 1KB = 1024 byte
+ 2^10 = 1024 btye

+ 字节以上的转换单位都是1024，字节以下一个字节等于八个位

**兆字节(MB)**:

+ 1MB = 1024KB
+ 1GB  = 1024MB
+ 1TB = 1024GB

---------------

**拓展:  硬盘标注的容量与实际的容量不一样**

假设买的256G硬盘实际上只有238.4G，换算一下：

``硬盘厂商十进制计算：``256 G  = 256,000 MB = 256,000,000 KB = 256,000,000,000 Byte	**以1000为单位换算**

``操作系统二进制计算:``  256G = 262,144MB = 268,435,456KB = 274,877,906,944Byte	**以1024为单位换算**

``那么256G实际容量：``256,000,000,000Byte/1024MB/1024MB/1024MB = 238.4G

所以，买256G硬盘实际上只有238.4G，而且容量越大差距也就越大了。





## 2.3 进制转换

![image-20210306150216685](C基础.assets/进制转换_1-16604520004521.png)

### 2.3.1 **十进制转其他进制**

#### 2.3.1.1 法一: 短除法

+ 以十进制数520为例，分别转换为二进制、八进制和十六进制，转换过程如下：

![image-20210306152316069](C基础.assets/进制转换_2-16604520004522.png)



####  2.3.1.2 法二: 拼凑法

**2的n次方表**


![image-20220814132203034](C基础.assets/image-20220814132203034.png)

​    0.5 0.25 0.125

案例:

```c++
// 十进制:  533.125
533.125 = 512 + 4 + 1 + 0.125  // 对应2的n次方表 有的写1 没有写 0

//二进制
1000010101.001
```



###  2.3.2 **其他进制转十进制：位权相加**

本质就是权数

步骤:

1. 对其他进制从右往左依次开始编号，0 1 2 3 4 5 ...

2. 每一位的数通过公式 【数值 * 基数^编号】计算，
3. 把结果相加，即得到转换结果



以上面的520D的二进制、八进制和十六进制为例

```二进制10 0000 1000 转十进制```

```c
98 7654 3210 编号
10 0000 1000 B
1*2^9 + 0 + 1*2^3 = 512 + 0 + 8 = 520 D
```

``八进制1010 转十进制``

```c
3210 编号
1010 O
1*8^3 + 0 +1*8^0  = 520 + 8 =520 D  
```

``十六进制208 转十进制``

```c
210 编号
208 H
2*16^2 + 0 + 8*16^0 = 2*256 + 8 = 520 H  
```



####  2.3.2.1 **八进制、十六进制与二进制相互转换：拆位和拼凑**

本质还是拼凑

``八进制与二进制``

+ 一个八进制数可以拆分为3个二进制数，3个二进制数可以合成一个八进制数    

+ 八进制数  0-7

+ 不够三位凑成三位 (4 2 1)   如 : 011 --> 3  111 --> 7

  ```c++
  //二进制 转 八进制
  // 三位一组转二进制,不够三位凑成三位
  001 000 001 000 B
  1   0   1   0   O
      
  //八进制转二进制
  // 用拼凑法.相当于每个位转二进制,不够三位凑成三位
  1   3   1   4   5   2   0    O    
  001 011 001 100 101 010 000  B
  ```

  ![image-20220814133853156](C基础.assets/image-20220814133853156.png)

``十六进制与二进制``

+ 一个八进制数可以拆分为4个二进制数，4个二进制数可以合成一个十六进制数

+ 十六进制  0-9 A B C D E F (A代表10 以此类推)

+ 不够三位凑成四位 (8 4 2 1)     如: 1111 --> 15   --> F

  ```c++
  //二进制转十六进制
  //四位一组转二进制,不够三位凑成四位
  0010 0000 1000 B
  2    0    8    H
      
  //十六进制转二进制
  //用拼凑法.相当于每个位转二进制,不够三位凑成四位
  1    3    1    4    5    2    0    H
  0001 0011 0001 0100 0101 0010 0000 B    
  ```

  ![image-20220814133906336](C基础.assets/image-20220814133906336.png)





## 2.4 整数的存储方式

### 2.4.1 整数的存储方式

#### 2.4.1.1 机器数和机器数的真值

**1，机器数**

一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用机器数的**最高位**存放符号，正数为0，负数为1。

比如:  十进制中的数 +3 ，**计算机字长为8位**，转换成二进制就是0000 0011，如果是 -3 ，就是 100 00011 。这里的 0000 0011 和 1000 0011 就是机器数。



**2，机器数的真值**

**将带符号位的机器数对应的真正数值**称为**机器数的真值**。

因为第一位是符号位，所以机器数的形式值就不等于真正的数值。

例如: 上面的有符号数 1000 0011，其最高位1代表负，其真正数值是 -3，而不是形式值131（1000 0011转换成十进制等于131）。

比如：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1



#### 2.4.1.2 原码, 反码, 补码

在计算机中，数据有三种表现形式，分别为：原码、反码、补码

==总结:==

* 原码：最高位为符号位，0代表正，1代表负
* 反码：无符号或正数，原码 = 反码；负数反码  =  原码符号位不变，其余为取反
* 补码：无符号或正数，原码 = 反码； 负数补码  =  反码 + 1

**注：计算机存放数据都是用补码形式**



 **1. 原码**

+ **原码就是机器数的真值，原码是人脑最容易理解和计算的表示方式** 。  用第一位表示符号，其余位表示值。

比如：如果是8位二进制： 

```
[+1]原= 0000 0001    
[-1]原= 1000 0001
```

**因为第一位是符号位（即第一位不表示值，只表示正负）所以 8位二进制数的有效位就只有7位(2^7 = 128),    所以整数的( 0的源码有两个,这里先不考虑0), 取值范围就是：**  **[1111 1111 , 0111 1111]   即   [-127 , 127]**    

**那么一个字节的取值范围就是: **

![image-20220814150050977](C基础.assets/image-20220814150050977.png)



**2. 反码**

+ 正数的反码是其本身；
+ 负数的反码是在其原码的基础上，符号位不变，其余各个位取反。

比如：如果是8位二进制：

```
[+1] = [0000 0001]原 = [0000 0001]反
[-1] = [1000 0001]原 = [1111 1110]反
```



**3.补码**

+ 正数的补码就是其本身；
+ 负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(也即在反码的基础上+1)

比如：如果是8位二进制：

```
[+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补
[-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补
```

对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码再计算其数值。



#### 2.4.1.3   补码意义

* 统一了零的编码

| **十进制数** | **原码**  |
| ------------ | --------- |
| +0           | 0000 0000 |
| -0           | 1000 0000 |

| **十进制数** | **反码**  |
| ------------ | --------- |
| +0           | 0000 0000 |
| -0           | 1111 1111 |

| **十进制数** | **补码**                                              |
| ------------ | ----------------------------------------------------- |
| +0           | 0000 0000                                             |
| -0           | 10000 0000由于只用8位描述，最高位1丢弃，变为0000 0000 |



* 将减法运算转变为加法运算

  例如： 9 - 6

| **十进制数** | **原码**  |
| ------------ | --------- |
| 9            | 0000 1001 |
| -6           | 1000 0110 |

如果用原码计算：

| 0000 1001   |
| ----------- |
| 1000 0100 + |
| 1000 1111   |

结果： 9 - 6 = -15不正确

利用补码进行计算

| **十进制数** | 补码       |
| ------------ | ---------- |
| 9            | 0000  1001 |
| -6           | 1111  1010 |

| 0000 1001  |
| ---------- |
| 1111 1010  |
| 10000 0011 |

最高位的1溢出，剩余8位二进制表示为3，结果正确



#### 2.4.1.4 取数据

1. 无符号取数据： %u %lu   %llu  %o  %x  ...
2. 有符号取数据： %d  %ld  %lld  %f  %llf ...



**取数据步骤：**

* 高位如果是0， 代表正数   原码 = 反码 = 补码 ，原样输出

* 高位如果是1， 代表**负数 补码的 符号位不变，其余位取反 + 1**

  

注：**程序中的八进制和十六进制的数据，不用考虑正负，都按照无符号对待**

```c
void test01()
{
	char num = -15;
	//原码  1000 1111
	//反码  1111 0000
	//补码  1111 0001
    
	//有符号输出 
    //补码  1111 0001
    //原码  1000 1111
	printf("%d\n", num);   // -15

	//无符号输出
    //补码  1111 0001
    //原码  1111 0001
	printf("%u\n", num & 0x000000ff);
	//编译器自动让结果与 前3个字节为1 的数字 做了按位或操作
	/*
		0000 0000 0000 0000 0000 0000 1111 0001  反码
		1111 1111 1111 1111 1111 1111 0000 0000 |
		1111 1111 1111 1111 1111 1111 1111 0001  结果
	*/
}

void test02()
{

	char num = 0x9b;  // 16转2进制 这个就是 1001  1011  就是补码 
	//计算机原样存储  
    
	// 有符号取
	// 补码 1001  1011
	//变回去 原码 1110  0101  =  -（64 + 32 + 4 + 1） = - 101
	printf("%d\n", num);

	//无符号取
	printf("%x\n", num & 0x000000ff); //9b
	printf("%u\n", num & 0x000000ff); // 128 + 16 + 8 + 2 + 1 = 155
}
```

------------

**补充printf格式化输出: **

```c
void test01()
{
	int a = 10;

	printf("十进制：%d\n", a);
	printf("八进制：%#o\n", a);
	printf("十六进制：%#x\n", a);
	printf("十六进制：%#X\n", a);
}

void test02()
{
	int a = 123;		//十进制方式赋值
	int b = 0123;		//八进制方式赋值， 以数字0开头
	int c = 0xabc;	    //十六进制方式赋值

	printf("十进制：%d\n", a);
	printf("八进制：%#o\n", b);	  //%o,为字母o,不是数字
	printf("十六进制：%#x\n", c);
}

int main(void)
{
    test01();
    test02();
    return 0;
}
```

结果;

```
十进制: d
八进制: 012
十六进制: 0xa
十六进制: 0XA

十进制: 123
八进制: 0123
十六进制: 0xabc
```



####  2.4.1.5 总结

一共有多少二进制位数要看具体情况   如: 类型 char 1字节(8位) --->8个二进制个数

```c
负数(高位1):   反码(符号位不变) + 1;
无符号取/正数/八进制 十六进制的数据:  原反补都相同
如果八进制,十六进制的数据 要用有符号取, 就需要考虑正负了
```

**使用计算器:**

+ 有符号去看高位,0用最高位判断正负, 按在计算机上最高位都用0
+ 无符号最高位是多少, 按在计算机上最高位就用多少




---------



### 2.4.2 小数的存储方式

现如今的计算机中浮点数的存储都是遵循IEEE754/854标准，以**二进制的科学计数法存放到内存中。**

对于浮点数在计算机中有两种存储的精度，**即单精度和双精度，单精度是32位，双精度是64位。**

![image-20210306192326642](C基础.assets/小数存储_total-16604520004533.png)

+ 符号位S：0为正，1为负

+ 指数E：即阶码，指明了小数点在数据中的位置

  + 为了让指数表示正、负引入了偏差码，
  + float的为127

    + ![image-20220814152040440](C基础.assets/image-20220814152040440.png)
  + double的为1024

+ 尾数M：**小数点后面的部分**

  ----------------------

**十进制小数  转  二进制小数-**-

+ 先把整数部分转化为二进制
+ 再把小数部分转化为二进制(**用2乘以小数部分，每次将结果整数取出，然后用剩余小数部分继续乘以2，直到小数部分为零，**或者达到要求的精度为止)

**例子1:**

十进制小数:   float f =   5.25 

1. 整数部分转二进制：5     ->  101

2. 小数部分转二进制

   ```c
   //小数部分转二进制：0.25  ->  0.01
   
   0.25 * 2 = 0.5  --- 0
   0.5  * 2 = 1.0  --- 1  
       
   //得小数部分：0.01    
   ```

​    3.  最后结果转成科学计数法：101.01 = 1.0101 * 2^2

可见指数实际值为2，加上偏差码127，2 + 127 = 129，129的二进制为10000001B.

**5.25在内存中的存储情况为:**

|  S   |  E(阶码)  | M(小数点后面的部分)(23位及23个二进制数) |
| :--: | :-------: | :-------------------------------------: |
|  0   | 1000 0001 |      0101 0000 0000 0000 0000 000       |

**如果把这个值作为整型使用，将是一个很大的数字，是1084751872**



**例子2:**

十进制小数:    float f = 5.20

1. 先把整数部分转成二进制:5- > 101

2. 把小数部分转为二进制:

   ```c
   //小数部分转二进制：0.20  -> 0.00110011
   0.20 * 2 = 0.4-0
   0.4* 2 = 0.8- 0
   0.8 *2 = 1.6- 1
   0.6* 2 = 1.2-1
   0.2 *2 = 0.4-0
   
   //得小数部分: 0.00110011
   ```
   
3. 最后结果转成科学计数法: 101.00110011 =  1.0100110011 *2^2

------------------------



把这个内存里面的值转为十进制小数：

例子:

计算机存储的小数(5.25):   0  1000 0001  0101 0000 0000 0000 0000 000

```c
//1, 首先判断S表示的正负      +
//2，计算出E实际表示的指数   1000 0001 = 129    129 - 127 = 2
//3，根据M写出二进制小数形式  1.0101 * 2^2  = 101.01
//4，对二进制小数以小数点为界限开始编号(使用加权法或者用拼凑法)

210 -1-2 编号
101. 0 1 B
1*2^2 + 0 + 1*2^0 + 0*2^(-1) + 1*2^(-2) = 4 + 1 +  0.25 =5.25   
```



**注意：**

- 在二进制，第一个有效数字必定是“1”，因此这个“1”并不会存储。 (阶码的原因)

- 浮点数不能精确表示其范围内的所有数。会精度丢失

  例子:   小数5.20 

  <img src="C基础.assets/image-20220814161006312.png" alt="image-20220814161006312" style="zoom:50%;" />

- 可精确表示的数不是均匀分布的，越靠近0越稠密。



补充例子

1、把二进制 101000000111011011000转换为 十进制 八进制 十六进制的数，要有过程。（必做）

```
101000000111011011000

21 .. 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
加权法
```

2、尝试写出 9 - 13=-4 的二进制计算过程。（必做）

```
9:  0000 1001
13: 1000 1101
补码:
0000 1001
1111 0011
= 1111 1100

取数据:
1000 0011 + 1
= 1000 0100
结果为4
```

3、现有一单精度小数的二进制存储形式`1 1000 0011  011101`，请算出对应的十进制小数，要有过程（必做）

```
单精度小数 32
// 127
1 1000 0011  011101
1 -->  -
1000 0011 ---> 221 ---> 221 - 127 = 4 
0.011101 ---> 111.01
111.01 -->转二进制 11.25
```





# 三、基础数据类型



## 3.1 标识符和命名规范

标识符是编程时使用的名字，用于给变量、常量、函数、语句块等命名，以建立起名称与使用之间的关系。

C语言中把标识符分为三类：关键字，预定义标识符，用户自定义标识符 ,对于自定义标识符有如下规则和规范

**命名基本规则**

+ 标识符由字母（A-Z，a-z）、数字（0-9）、下划线“_”组成，并且首字符不能是数字，但可以是字母或者下划线。例如，正确的标识符：abc，a1，prog_to。
+ 不能把C语言关键字作为用户标识符，例如if，for，while等。
+ 标识符对大小写敏感，即严格区分大小写。
+ 标识符命名应做到**“**见名知意**”**，例如，长度（length），求和、总计（sum），圆周率（pi）……

**常用命名规范**

+ 小驼峰(推荐)
  + 第一个单词首字母小写，后面其他单词首字母大写
  + 如：myName  youAge
+ 大驼峰
  + 所有单词的首字母都大写
  + 如MyName YouAge
+ 匈牙利
  + 在标识符前面加上小写字母作为前缀，标识出变量的作用域，类型等等
  + g_   全局变量 
  + c_   常量 
  + s_   静态成员变量

注意：写项目的时候，保持一种标准，建议使用小驼峰（工作了看企业需求）



## 3.2 常量与变量

### **3.2.1 常量**

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。

常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。

#### 3.2.1.1  整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制(VS2019支持二进制常量表示：0b或0B表示二进制)。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

```c
80			//十进制
0120		//八进制
0X50		//十六进制
0B1010000	//二进制
```



#### 3.2.1.2 浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

```c
0.25;		//合法
.25;		//合法 	相当于0.25
5.;			//合法 	相当于5.0

314159E-5;	//合法	3.14159;
314159E;	//非法	应输入指数值而非“;”
.E-5;		//非法	缺少整数或者分数
```



#### 3.2.1.3 字符常量

字符常量是括在单引号中，例如，'x' 。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t')，或一个通用的字符（例如 '\u02C0'）。

**ASCII字符代码表：**

<img src="C基础.assets/ascii-16605333809532.jpg" alt="img"  />



**转义字符:**一种特殊的字符常量

+ 以反斜线"\"开头，后跟一个或几个字符。
+ 转义字符具有特定的含义，不同于字符原有的意义，故称“转义”字符。
+ 转义字符中只能使用小写字母，每个转义字符只能看作一个字符。
+ ‘\v’垂直制表和‘\f’换页符对屏幕没有任何影响，但会影响打印机执行响应操作。

下表列出了一些这样的转义序列码：

| 转义序列 | 含义                | ASCII码值(十进制) |
| :------- | :------------------ | ----------------- |
| \\\2     | \ 字符              | 092               |
| \\'      | ' 字符              | 039               |
| \\"      | " 字符              | 034               |
| \a       | 警报铃声            | 007               |
| \b       | 退格键              | 008               |
| \f       | 换页符              | 012               |
| \n       | 换行符              | 010               |
| \r       | 回车                | 013               |
| \t       | 水平制表符          | 009               |
| \v       | 垂直制表符          | 011               |
| \0       | 空字符(NULL)        | 000               |
| \ddd     | 一到3位的八进制数   | -                 |
| \xhh     | 一到2位的十六进制数 | -                 |



#### 3.2.1.4 字符串常量

字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

可以使用空格做分隔符，把一个很长的字符串常量进行分行。

下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。

```c
"hello,world";

"hello,\
world";

"hello,""w""orld";
```



#### 3.2.1.5 定义常量

在 C 中，有两种简单的定义常量的方式：

1. 使用 **#define** 预处理器。
2. 使用 **const** 关键字。

**#define 预处理器**

>#define identifier value	/\*#define 标识符  常量值\*/

*示例：*

```c
#include<stdio.h>

#define PI 3.1415

int main()
{
	printf("圆的面积为:%lf",PI*3*3);   
    return 0;
}
//output:圆的面积为:28.273500
```

**const关键字**

使用 **const** 前缀声明指定类型的常量，如下所示：

> const type variable = value;

<img src="C基础.assets/c-const-2021-01-15-16605333809543.png" alt="img" style="zoom: 67%;" />

const 声明常量要在一个语句内完成：

<img src="C基础.assets/c-const-2021-01-15-2-16605333809556.png" alt="img" style="zoom: 67%;" />

具体请看下面的实例：

*示例：*

```c
#include<stdio.h>

int main()
{
    const float PI = 3.1415f;
	printf("圆的面积为:%f",PI*3*3);   
    return 0;
}
//output:圆的面积为:28.273500
```

请注意，把常量定义为大写字母形式，是一个很好的编程习惯。



### 3.2.2 变量

变量来源于数学，是计算机语言中能储存计算结果或能表示值的抽象概念。

每种变量都有对应的数据类型，有不同大小的存储空间*(为了适应不同的数据类型，也为了节省内存)*，在C语言中主要有如下**基础数据类型**。

![image-20210330023307228](C基础.assets/image-20210330023307228-16605333809554.png)

+ 实型默认都是double型
+ 整型默认都是int型
+ 所有类型默认都是有符号(signed)型

#### 变量的定义

定义变量就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。

不过，我们必须给变量取一个合适的名字，就好像每个人都有自己的名字一样，否则就难以区分了。

> type variable_list

在这里，**type** 必须是一个有效的 C 数据类型，可以是 char、int、float、double 或任何用户自定义的对象，**variable_list** 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：

```cpp
int age,money;
char sex;
float PI;
```

变量可以在定义的时候被赋值，这种在定义是指定一个初始值的方式叫做变量的初始化。

```c
int age = 18;	//初始化
age = 19;		//赋值
```

>不带初始化的定义：变量的初始值是未定义的。



### 左值（Lvalues）和右值（Rvalues）

C 中有两种类型的表达式：

1. **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
2. **右值（rvalue）：**右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：

```c
int g = 20;		//g是左值
```

但是下面这个就不是一个有效的语句，会生成编译时错误：

```c
10 = 20;		//10是右值
```



## 数据类型转换

数据类型转换就是将数据（变量、数值、表达式的结果等）从一种类型转换为另一种类型。

**自动类型转换**

自动类型转换就是编译器默默地、隐式地、偷偷地进行的数据类型转换，这种转换不需要程序员干预，会自动发生。

1) 将一种类型的数据赋值给另外一种类型的变量时就会发生自动类型转换，例如：

```cpp
float f = 100;
```

100 是 int 类型的数据，需要先转换为 float 类型才能赋值给变量 f。再如：

```cpp
int n = f;
```

f 是 float 类型的数据，需要先转换为 int 类型才能赋值给变量 n。

在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型转换为左边变量的类型，这可能会导致数据失真(数据输入和输出不一致)，或者精度降低；所以说，自动类型转换并不一定是安全的。对于不安全的类型转换，编译器一般会给出警告。

2) 在不同类型的混合运算中，编译器也会自动地转换数据类型，将参与运算的所有数据先转换为同一种类型，然后再进行计算。转换的规则如下：

- 转换按数据长度增加的方向进行，以保证数值不失真，或者精度不降低。例如，int 和 long 参与运算时，先把 int 类型的数据转成 long 类型后再进行运算。
- 所有的浮点运算都是以双精度进行的，即使运算中只有 float 类型，也要先转换为 double 类型，才能进行运算。
- char 和 short 参与运算时，必须先转换成 int 类型。

![img](C基础.assets/134S535R-0-16605333809555.png)



自动类型转换示例：

```c
#include<stdio.h>
int main()
{    
    float PI = 3.14159;    
    int s1, r = 5;    
    double s2;    
    s1 = r * r * PI;    
    s2 = r * r * PI;    
    printf("s1=%d, s2=%f\n", s1, s2);    
    return 0;
}
```

运行结果：
s1=78, s2=78.539749

在计算表达式`r*r*PI`时，r 和 PI 都被转换成 double 类型，表达式的结果也是 double 类型。但由于 s1 为整型，所以赋值运算的结果仍为整型，舍去了小数部分，导致数据精度丢失。



## 强制类型转换

自动类型转换是编译器根据代码的上下文环境自行判断的结果，有时候并不是那么“智能”，不能满足所有的需求。如果需要，程序员也可以自己在代码中明确地提出要进行类型转换，这称为强制类型转换。

强制类型转换的格式为：

```c
(type) expression
```

`type`为目标类型名称，`expression`为表达式。例如：

```c
(float) a;  //将变量 a 转换为 float 类型
(int)(x+y);  //把表达式 x+y 的结果转换为 int 整型
(float) 100;  //将数值 100（默认为int类型）转换为 float 类型
```

下面是一个需要强制类型转换的经典例子：

```c
#include <stdio.h>
int main()
{    
    int sum = 315;  //总数    
    int count = 7;  //数目    
    double average;  //平均数    
    average = (double) sum / count;    
    printf("Average is %lf!\n", average);    
    return 0;
}
output:Average is 44.714286!
```

sum 和 count 都是 int 类型，如果不进行干预，那么`sum / count`的运算结果也是 int 类型，小数部分将被丢弃；虽然是 average 是 double 类型，可以接收小数部分，但是心有余力不足，小数部分提前就被“阉割”了，它只能接收到整数部分，这就导致除法运算的结果严重失真。

既然 average 是 double 类型，为何不充分利用，尽量提高运算结果的精度呢？为了达到这个目标，我们只要将 sum 或者 count 其中之一转换为 double 类型即可。上面的代码中，我们将 sum 强制转换为 double 类型，这样`sum / count`的结果也将变成 double 类型，就可以保留小数部分了，average 接收到的值也会更加精确。

> 注意不要写作`(double) (sum / count)`，这样写运算结果将是 44.000000，仍然不能保留小数部分。





# 基本输入输出

若需要使用输入输出函数，则需要包含<stdio.h>头文件。

## 输出

#### printf

printf是最常用的输出函数，可以格式化输出任意的基本数据类型的变量。

```c
int printf(const char*format,...)
```

+ format："格式控制符"是用双引号括起来的字符串（格式控制符，也叫[占位符](#占位符(格式控制符))）
+ ...："输出列表"中的数据可以是合法的常量、变量和表达式，要与“格式控制字符串”中的格式一一对应。



#### putchar

有些时候，仅仅为了打印一个字符在显示器屏幕上，此时动用功能强大的printf函数，则颇有高射炮打蚊子之嫌，C提供了一个库函数putchar来完成这个简单的任务。

```c
int putchar(int ch);
putchar('A');
puchar(65);
```



#### puts

而有些时候仅仅是为了输出一个字符串，使用printf函数也稍显麻烦，可以使用C提供的一个库函数puts，而且puts函数会在输出字符串之后，自动进行换行。

```c
int puts(const char*str);
puts("hello world");	
```



## 输入

#### scanf

scanf是最常用的输入函数，可以格式化输入任意基本数据类型的变量。

```c
int scanf(const char* format,...);
```

+ format："格式控制符"是用双引号括起来的字符串
+ ...："输入列表"中的数据必须是合法变量的地址表(即变量前面加&符)，要与“格式控制字符串”中的格式一一对应。
+ 如果输入的输入不止一个，在format格式控制字符串中，必须以空格间隔。

**示例：**

```c
const double PI = 3.1415;
int  radius = 0;
printf("请输入半径:\n");
scanf("%d", &radius);
printf("圆的面积为:%lf", PI * radius * radius);
```



 **scanf函数注意事项**

*scanf函数的格式字符串由以下三类字符组成：*

+ 1>格式符(也叫占位符)
  和printf函数类似，scanf函数的格式字符串以%开始，以一个格式字符结束，中间可以插入附加的字符。格式符告诉了scanf函数该读取什么样的数据。

+ 2>空白符
  空白符可以是空格(用空格键输入)、制表符(用Tab键输入)和新行符(用回车键输入)。

+ 3>非空白符
  除去格式说明符合空白符之外，就是非空白符。非空白符在用户输入的时候，也必须一并输入。


  ​                    

#### getchar

可以非常方便的输入一个字符。

```c
int getchar();
```



#### gets_s

可以非常方便的输入一个字符串。

```c
char* gets_s(char*  _Buffer,size_t _Size);
```



## 占位符(格式控制符)

占位符就是先占住一个固定的位置，等着你再往里面添加内容的符号，广泛用于计算机中各类文档的编辑。

格式占位符(%)是在C/C++语言中格式输入函数，如 scanf、printf 等函数中使用。其意义就是起到格式占位的意思，表示在该位置有输入或者输出。

C语言中，有专门的格式占位符对整型、浮点型、指针类型进行输入输出。

### 整型

+ 常用

| 占位符 | 说明                   |
| ------ | ---------------------- |
| %hd    | short                  |
| %hu    | unsigned short         |
| %d，%i | int类型                |
| %u     | unsigned int类型       |
| %ld    | long int               |
| %lu    | unsigned long int      |
| %lld   | long long int          |
| %llu   | unsigned long long int |
| %c     | char                   |

+ 指定进制输出

| 占位符 | 说明                                                       |
| ------ | ---------------------------------------------------------- |
| %o     | 有符号八进制整数                                           |
| %x，%X | 无符号十六进制整数，并以小写abcdef表示\|并以大写ABCDEF表示 |

如果想要输出相应的进制的前缀，可以在%和符号之间加上#。

```c
int  a = 10;
printf("%#o\n", a);
printf("%#x %#X\n", a, a);
```

**OUTPUT：**

```cpp
012
0xa 0XA
```



### 浮点型

| 占位符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| %f     | float                                                        |
| %lf    | double                                                       |
| %e，%E | 以指数形式输出浮点数(输入时小数形式和指数形式都可以识别)     |
| %g，%G | 自适应输出小数或者指数形式(输入时小数形式和指数形式都可以识别) |

+ %g用来输出实数，它根据数值的大小，自动选f格式或e格式（选择输出时占宽度较小的一种），且不输出无意义的0。

```c
printf("%g\n", 0.00001234);		//1.234e-05
printf("%g\n", 0.0001234);		//0.0001234
```



### 指针类型

| 占位符 | 说明                     |
| ------ | ------------------------ |
| %p     | 以十六进制的方式输出地址 |

### 字符串

| 占位符 | 说明                      |
| ------ | ------------------------- |
| %s     | 输出/输入以\0结尾的字符串 |
| %[]    | 输入字符串的特殊占位符    |

％[ ]，这个参数的意义是读入一个字符集合。[ ]是个集合的标志，因此%[ ]特指读入此集合所限定的那些字符,比如%[A-Z]是输入大写字母，一旦遇到不在此集合的字符便停止。如果集合的第一个字符是"^"，这说明读取不在"^"后面集合的字符，既遇到"^"后面集合的字符便停止。如果要在循环中用**scanf(**"%\[^\n] "**, s)**读取多行的字符串，就要在读取一行后，再用scanf(“%c”,ch) 或者getchar()函数读取一个字符(**换行符)**，将输入缓冲区中的换行符给读出来。否则的话，在下一次读取一行的时候，第一个就遇到'\n'，就会读入一个空字符串。

### 格式控制符可选项

```c
%[-][0][M]*
```

+ % 和 *组成占位符
+ M：表示以指定的宽度输出，若数据的位数小于M，则左侧补空格；若M前面有"C"，则左端补''C"
+ 0：如果指定了'0'，则以'0'进行填充
+ -：表示左对齐  + 表示右对齐



### 注意事项：

*很多同学在输出的时候，会遇到很多啊问题，大概就是以下几点：*

+ 格式字符中，除了X、E、G外，其他均用小写字母，如“%d”不能写成“%D”。
+ 不同类型的数据应使用相应类型的格式字符说明其输出形式。
+ 如需输出双引号，应在“格式控制”中表示为转义字符的形式并用单引号引起来，即“\””。
+ 如需输出字符“％”，在“格式控制”中用连续两个“％”即可。
  如：printf(“%d%%”,s);
+ 当“格式控制”中格式符个数少于输出表中的输出项时，多余的输出项不予输出。
+ 当“格式符”多于输出项时，结果为不定值。

