- C++中的栈

C++ 对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了[数据结构](https://so.csdn.net/so/search?q=数据结构&spm=1001.2101.3001.7020)和算法的分离。STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模版函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文件：<algorithm >、<deque >、<functional>、<iterator>、<vector>、<list>、<map>、<memory>、<numeric>、<queue>、<set>、<stack>和<utility>。其中的<stack>就是栈。

C++的STL已经将栈的操作都封装成了函数，我们只需要引进#include<stack>头文件即可使用。

# C++中栈的基本操作

初始化

我们可以直接使用stack<int> s;来创建一个空的 stack 对象。

判断是否为空栈

使用empty()函数来判断栈是否为空。
![empty()函数详解](数据结构和算法c++.assets/20200419233148364.png)

入栈

使用push()函数来完成入栈操作。
![push()函数详解](数据结构和算法c++.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTc1NTA3,size_16,color_FFFFFF,t_70.png)

出栈

使用pop()函数实现出栈
![pop()函数详解](数据结构和算法c++.assets/20200419233247129.png)

返回栈顶元素



**C++中stack，其中有两个方法：**

**pop(), 返回void,**

**top(),返回栈顶的引用。**

**所以想要提取栈顶元素，直接用s.top()**



使用top()函数返回栈顶元素
![top()函数详解](数据结构和算法c++.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTc1NTA3,size_16,color_FFFFFF,t_70-16501131676981.png)

返回栈中元素数目

使用size()函数返回栈中元素的数目。
![size()函数详解](数据结构和算法c++.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTc1NTA3,size_16,color_FFFFFF,t_70-16501131676992.png)







C++ Stack（堆栈） 是一个容器类的改编，为程序员提供了堆栈的全部功能，——也就是说实现了一个先进后出

```c++
（FILO）的数据结构。
操作       比较和分配堆栈 
empty()   堆栈为空则返回真 
pop()     移除栈顶元素 
push()    在栈顶增加元素 
size()    返回栈中元素数目 
top()     返回栈顶元素 
Lists将元素按顺序储存在链表中. 与 向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢. 
assign() 给list赋值 
back() 返回最后一个元素 
begin() 返回指向第一个元素的迭代器 
clear() 删除所有元素 
empty() 如果list是空的则返回true 
end() 返回末尾的迭代器 
erase() 删除一个元素 
front() 返回第一个元素 
get_allocator() 返回list的配置器 
insert() 插入一个元素到list中 
max_size() 返回list能容纳的最大元素数量 
merge() 合并两个list 
pop_back() 删除最后一个元素 
pop_front() 删除第一个元素 
push_back() 在list的末尾添加一个元素 
push_front() 在list的头部添加一个元素 
rbegin() 返回指向第一个元素的逆向迭代器 
remove() 从list删除元素 
remove_if() 按指定条件删除元素 
rend() 指向list末尾的逆向迭代器 
resize() 改变list的大小 
reverse() 把list的元素倒转 
size() 返回list中的元素个数 
sort() 给list排序 
splice() 合并两个list 
swap() 交换两个list 
unique() 删除list中重复的元素 
```





# 哨兵节点

   哨兵节点广泛应用于树和[链表](https://so.csdn.net/so/search?q=链表&spm=1001.2101.3001.7020)中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。

问题：删除链表中等于给定值val的所有节点。
1，如果节点在中间，只需将该节点进行删除即可。
2，如果节点在头部，则问题将有点复杂，不能直接将头节点删掉，这样会造成链表的丢失。**通过设置哨兵节点，用来临时保存头部节点，最后在计算完毕以后，返回该节点。**
代码如下：



```c++
struct ListNode* removeElements(struct ListNode* head, int val)
{
    if (head == NULL)
        return NULL;
    struct ListNode *ret = (struct ListNode*)malloc(sizeof(struct ListNode));
    ret->next = head;
    struct ListNode *pre = ret;
    struct ListNode *cur = head;
    while (cur != NULL)
    {
        if (cur->val == val)
        {
            pre->next = cur->next;
            cur = cur->next;
        }
        else
        {
            cur = cur->next;
            pre = pre->next;
        }
    }
	return ret->next;
}
```

————————————————



## 题21、合并两个有序链表

```c++
ListNode prehead = new ListNode(-1) //新建哑节点，值为-1
或 ListNode L1 = new ListNode(0)
每个节点都有一个值
主要有两个操作
prehead.next=L1//将L1连接到prehead之后。
prehead = prehead.next;//将指针指向后一个节点，既L1.


-------------------
    
  ListNode* preHead = new ListNode(-1); //动态创建哑节点，值为-1 
  ListNode* pre = preHead; //成为新的头节点,真链表的头节点就preHead->next //head节点也有prev指针了,这里可以保持头不变
 之后怎么用前驱点就怎么用
```

其他: 

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

    ListNode *reverseBetween(ListNode *head, int m,int n){
        ListNode dummy(-1);//定义一个假的节点，不是指针，是一个局部变量。
        dummy.next = head;//成为新的头节点，这样真链表的头节点就是dummy.next
　　　　　　　　　　　　　　　//这时候，我们的head节点也有prev指针了，head和其他节点在前驱指针这一方面，就没有区别了。
        ListNode *prev = &dummy;
        for(int i = 0;i<m-1;i++){//我们的prev应该指向的是，第m个节点的前驱节点
            prev = prev->next;
        }//跳出循环后我们的prev就是指向第m个节点前驱节点

        ListNode *const head2 = prev;///把这个前驱节点 记做head2，因为后面要采用头插法的方式来build 链表，什么是头插法，什么是尾插法，这个一定要弄清楚了。

        prev = head2->next;///prev现在指的是第m个节点，
        ListNode *curr = prev->next;///curr指向prev的下一个节点
        for(int i = m;i<n;i++){///对于每一个i (m<i<=n)的节点，利用头插法插入到head2所在的链表中。

　　　　　　　　　　[===]　　...　　[===]  [===]  [===]
　　　　　　　　　　head2   　　   　prev   curr   

            prev->next = curr->next;///这一步之后curr就独立了
            curr->next = head2->next;///1
            head2->next = curr;///2  这一步和上一步就是头插法了
            curr = prev->next;////curr指针后移一个位置
        }

        return dummy.next;
    }
```





## 哨兵节点的创建链表

- 不带哨兵节点的创建链表(尾插法)

```C++
// 用一个vector<int> 初始化链表(不带头结点)
// 尾差法
void InitLinkList1(ListNode* &L,vector<int> v) 
{
	CreateLinkList1(L);
	ListNode *pCur=NULL;   //节点
	for (unsigned int i = 0; i < v.size(); i++) 
    {
		if (L == NULL) 
        {// 头结点特殊处理
			pCur = new ListNode(v[i]);   // 初始化相当于在 p->elem = elem; // 数据域
   										// p->next = NULL; //指针域,刚刚创建,指针域应该是空的
			L = pCur;
		}
        else 
        {
			pCur->next = new ListNode(v[i]);
			pCur = pCur->next;
		}
	}
}

// c
void create_list(unsigned char elem)
{
    //创建节点:
    struct node *p = (struct node *)malloc(sizeof(struct node));   // 开辟内存空间放置节点 malloc返回void的类型 通过(struct node *)进行强制类型转换指针   // c++ 用new
    p->elem = elem; // 数据域
    p->next = NULL; //指针域,刚刚创建,指针域应该是空的
    // 上述是初始化

    
    // 链接节点:  p就代表加入的节点数据,本身是变的
    if (head == NULL)   //第一个节点加入时(第一次插入新节点时)//头指针必须指向第一个节点 
                        //在第一个节点加入尾指针指向和头指针一样
        head = p;
    else                // 再插入其他的新来节点   // 此时的尾节点的指针域应该切换到新来的
        tail->next = p;  //用尾指针 tail里面的指针域应该指向下一个位置  如图
    tail = p;   //tail指针指向新的节点  如图上(tail指针移动)(更新) // 操作
}
```

- 带哨兵节点的创建链表(尾插法)

```C++
// 用一个vector<int> 初始化链表(带头结点)
void InitLinkList2(ListNode*& L, vector<int> v) 
{
	CreateLinkList2(L);
	ListNode *pCur = L;  // L是头节点!
	for (unsigned int i = 0; i < v.size(); i++)
    {
		ListNode *pNode = new ListNode(v[i]);
		pCur->next = pNode;
		pCur = pNode;
	}
}
```